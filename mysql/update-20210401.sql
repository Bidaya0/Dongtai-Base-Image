SET FOREIGN_KEY_CHECKS=0;

INSERT INTO `django_celery_beat_intervalschedule`(`id`, `every`, `period`) VALUES (1, 10, 'seconds');
INSERT INTO `django_celery_beat_intervalschedule`(`id`, `every`, `period`) VALUES (2, 1, 'hours');
INSERT INTO `django_celery_beat_intervalschedule`(`id`, `every`, `period`) VALUES (3, 5, 'minutes');
INSERT INTO `django_celery_beat_intervalschedule`(`id`, `every`, `period`) VALUES (4, 1, 'days');
INSERT INTO `django_celery_beat_intervalschedule`(`id`, `every`, `period`) VALUES (5, 30, 'days');
 
INSERT INTO `django_celery_beat_periodictask`(`name`, `task`, `args`, `kwargs`, `queue`, `exchange`, `routing_key`, `expires`, `enabled`, `last_run_at`, `total_run_count`, `date_changed`, `description`, `crontab_id`, `interval_id`, `solar_id`, `one_off`, `start_time`, `priority`, `headers`, `clocked_id`, `expire_seconds`) VALUES ('engine.heartbeat', 'core.tasks.heartbeat', '[]', '{}', NULL, NULL, NULL, NULL, 1, '2021-05-08 05:34:02.743450', 509, '2021-05-08 05:35:33.100817', '', NULL, 2, NULL, 0, NULL, NULL, '{}', NULL, NULL);
INSERT INTO `django_celery_beat_periodictask`(`name`, `task`, `args`, `kwargs`, `queue`, `exchange`, `routing_key`, `expires`, `enabled`, `last_run_at`, `total_run_count`, `date_changed`, `description`, `crontab_id`, `interval_id`, `solar_id`, `one_off`, `start_time`, `priority`, `headers`, `clocked_id`, `expire_seconds`) VALUES ('engine.update_agent_status', 'core.tasks.update_agent_status', '[]', '{}', NULL, NULL, NULL, NULL, 1, '2021-05-08 06:25:47.527645', 2509, '2021-05-08 06:27:22.947828', '', NULL, 3, NULL, 0, NULL, NULL, '{}', NULL, NULL);
INSERT INTO `django_celery_beat_periodictask`(`name`, `task`, `args`, `kwargs`, `queue`, `exchange`, `routing_key`, `expires`, `enabled`, `last_run_at`, `total_run_count`, `date_changed`, `description`, `crontab_id`, `interval_id`, `solar_id`, `one_off`, `start_time`, `priority`, `headers`, `clocked_id`, `expire_seconds`) VALUES ('engine.update_sca', 'core.tasks.update_sca', '[]', '{}', NULL, NULL, NULL, NULL, 1, '2021-05-08 06:25:35.184066', 8, '2021-05-08 06:27:22.926700', '', NULL, 4, NULL, 0, NULL, NULL, '{}', NULL, NULL);

INSERT INTO `iast_deploy`(`desc`, `middleware`, `os`) VALUES ('**手动修改**\n\n进入tomcat主目录，找到`bin/catalina.sh`文件，在**文件首行**增加如下配置：\n```bash\nCATALINA_OPTS=\"-javaagent:/path/to/server/agent.jar -Dproject.name=<project name>\"\n```\n\n**注意：**`<project name>`与创建的项目名称保持一致，agent将自动关联至项目；如果不配置该参数，需要进入项目管理中进行手工绑定。', 'tomcat', 'linux');
INSERT INTO `iast_deploy`(`desc`, `middleware`, `os`) VALUES ('####  JBossAS 6\n\n进入JBoss容器的主目录，在`bin/run.sh`文件中找到`# Setup JBoss specific properties`所在行，在该行的下面插入如下行：\n```bash\nJAVA_OPTS=\"$JAVA_OPTS \"-javaagent:/path/to/server/agent.jar\" \"-Dproject.name=<project name>\n```\n**注意：**`<project name>`与创建的项目名称保持一致，agent将自动关联至项目；如果不配置该参数，需要进入项目管理中进行手工绑定。\n\n\n#### JBossAS 7、JBossWildfly\n\n进入JBoss容器的主目录，根据当前服务器的启动类型：standalone、domain修改对应的配置文件\n\n##### Standalone模式\n打开`bin/standalone.sh`文件，定位`# Display our environment`所在的行，在其上方插入自定义配置，如下：\n```bash\nJAVA_OPTS=\"$JAVA_OPTS \"-javaagent:/path/to/server/agent.jar\" \"-Dproject.name=<project name>\n```\n**注意：**`<project name>`与创建的项目名称保持一致，agent将自动关联至项目；如果不配置该参数，需要进入项目管理中进行手工绑定。\n\n##### domain模式\ndomain模式下的部署方式与Standalone模式类似，请自行查询', 'jboss', 'linux');
INSERT INTO `iast_deploy`(`desc`, `middleware`, `os`) VALUES ('> Jetty\n#### 手工修改\n1.进入jetty的根目录，打开`bin/jetty.sh`文件，找到`Add jetty properties to Java VM options.`所在行，在下面行插入`JAVA_OPTIONS+=( \"-javaagent:/opt/agent/agent.jar=token=e7509bf7-e44f-4e1f-8e25-5079e2540c63\")`\n\n2.重启jetty服务器\n\n#### 自动修改\n进入tomcat容器的主目录，找到`bin/jetty.sh`文件，使用下面的shell命令修改jetty.sh文件\n```bash\nsed \"$(cat jetty.sh |grep -n \\\"Add jetty properties to Java VM options\\\"|cut -d \":\" -f1) aJAVA_OPTS=\\\"\\$JAVA_OPTS\\ \\\"-javaagent:/opt/agent/agent.jar=token=e7509bf7-e44f-4e1f-8e25-5079e2540c63\" -i jetty.sh\n```', 'jetty', 'linux');
INSERT INTO `iast_deploy`(`desc`, `middleware`, `os`) VALUES ('> Resin\n#### 手动修改\n进入resin容器的主目录，打开`conf/cluster-default.xml`文件，定位到`<server-default>`所在的行，在该行下面插入`<jvm-arg>-javaagent:/opt/agent/agent.jar</jvm-arg>`', 'resin', 'linux');
INSERT INTO `iast_deploy`(`desc`, `middleware`, `os`) VALUES ('> WebLogic配置agent\n\n#### 手动修改\n**非集群方式**\n\n进入WebLogic目录，打开`bin/startWebLogic.sh`文件，找到`JAVA_OPTIONS=\"${SAVE_JAVA_OPTIONS}\"`所在行，在该行的下面增加一行\n\n```\nJAVA_OPTIONS=\"-javaagent:${DOMAIN_HOME}/agent/agent.jar\"\n```\n\n**集群方式**\n\n##### 方式一、通过weblogic的console\n\n访问weblogic的console，例如：\n\n1.找到“环境”下的“服务器”，然后在服务器列表中点击需要安装agent的服务器，如：AdminServer\n\n![img](https://i0x0fy4ibf.feishu.cn/space/api/box/stream/download/asynccode/?code=6920cd75d5484b9dcae5f67a8aad155f_8f118824ce50c961_boxcngZyBvKQSo849VNXlQBJuge_YuAYCtHZdJXJCwvIlL3fxPrHcOQuN1Ce)\n\n2.进入服务器详情，点击“服务器启动”，在下方的参数一栏中填入javaagent的参数`-javaagent:/opt/agent/agent.jar`，如：\n\n![img](https://i0x0fy4ibf.feishu.cn/space/api/box/stream/download/asynccode/?code=e32f0fdef6dc3e199632ee96e9e14aa5_8f118824ce50c961_boxcnfxBALg44nqZNvWICeYo93f_mfxihZ670SCKmxtDiZ3ykAkC556TiWMW)\n\n3.重启服务器，使配置生效\n\n![img](https://i0x0fy4ibf.feishu.cn/space/api/box/stream/download/asynccode/?code=346e5344abca7fae8d3cdc89c05f2fbd_8f118824ce50c961_boxcn3SbZEAQhl0B4RSMJpZbibv_o17TRySNfvsOwiyoAYdmpC7GU9XmegU4)\n\n\n\n##### 方式二、通过配置weblogic的config.xml文件\n\n找到`/u01/oracle/weblogic/user_projects/domains/base_domain/config`目录下的config.xml文件，定位到`<server-start>`标签下的`<arguments>`标签，在标签内添加如下配置：\n```\n-javaagent:/opt/agent/agent.jar\n```\n\n\n', 'weblogic', 'linux');
INSERT INTO `iast_deploy`(`desc`, `middleware`, `os`) VALUES ('> WebSphere\n![websphere-01](/upload/masterimg/websphere-01.png)\n![websphere-02](/upload/masterimg/websphere-02.png)\n![websphere-03](/upload/masterimg/websphere-03.png)\n', 'websphere', 'linux');
INSERT INTO `iast_deploy`(`desc`, `middleware`, `os`) VALUES ('> WebLogic\n![weblogic-01](/upload/masterimg/weblogic-01.png)\n![weblogic-02](/upload/masterimg/weblogic-02.png)\n![weblogic-03](/upload/masterimg/weblogic-03.png)\n![weblogic-04](/upload/masterimg/weblogic-04.png)', 'weblogic', 'windows');
INSERT INTO `iast_deploy`(`desc`, `middleware`, `os`) VALUES ('**SpringBoot**\n\n1. 下载`agent.jar`，然后放入具有写入权限的目录中，如：`/tmp/`\n\n2. 针对SpringBoot应用\n	1). 如果使用**war包**的方式部署，agent的安装方式为具体中间件的安装方式\n	2). 如果使用`java -jar app.jar`的方式部署，则直接在启动命令中增加启动参数`-javaagent:/path/to/agent.jar`即可，如：`java -javaagent:/path/to/agent.jar -Dproject.name=<project name> -jar app.jar`\n	\n**注意：**`<project name>`与创建的项目名称保持一致，agent将自动关联至项目；如果不配置该参数，需要进入项目管理中进行手工绑定。', 'SpringBoot', 'linux');
INSERT INTO `iast_deploy`(`desc`, `middleware`, `os`) VALUES ('**SpringBoot**\n\n1. 下载`agent.jar`，然后放入具有写入权限的目录中，如：`/tmp/`\n\n2. 针对SpringBoot应用\n	1）如果使用**war包**的方式部署，agent的安装方式为具体中间件的安装方式；\n	2）如果使用`java -jar app.jar`的方式部署，则直接在启动命令中增加启动参数`-javaagent:/path/to/agent.jar`即可，如：`java -javaagent:/path/to/agent.jar -Dproject.name=<project name> -jar app.jar`\n	\n**注意：**`<project name>`与创建的项目名称保持一致，agent将自动关联至项目；如果不配置该参数，需要进入项目管理中进行手工绑定。', 'SpringBoot', 'windows');

INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'cmd-injection', 1, 'enable', 1, '命令执行', '命令注入漏洞是指由于Web应用程序对用户提交的数据过滤不严格，导致黑客可以通过构造特殊命令字符串的方式，将数据提交至Web应用程序中，并利用该方式执行外部程序或系统命令实施攻击，非法获取数据或者网络资源等。', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'smtp-injection', 1, 'enable', 1, 'SMTP注入', '攻击者利用IMAP / SMTP服务器上输入验证的弱点在服务器上执行命令。Web邮件服务器通常位于Internet与IMAP或SMTP邮件服务器之间。Web邮件服务器接收到用户请求，然后Web邮件服务器向后端邮件服务器查询所请求的信息，并将此响应返回给用户。在IMAP / SMTP命令注入攻击中，邮件服务器命令嵌入在发送到Web邮件服务器的部分请求中。如果Web邮件服务器未能充分清理这些请求，则当Web邮件服务器查询后端服务器时，这些命令将被发送到后端邮件服务器，然后在此处执行命令。', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'ssrf', 1, 'enable', 1, '服务器端请求伪造', '将请求中的参数`<<<result_vul.information.probe.vulparam>>>`的内容设置为测试Payload:`<<<result_vul.information.probe.poc>>>`后进行分析发现<<<result_vul.information.description>>>，故判定该请求存在<<<vultags.tag_title>>>\r\n请求信息:\r\n```http<<=http-result_vul.information.probe=>>```\r\n响应信息:\r\n```http<<=httpresponse-result_vul.information.response=>>```', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'unsafe-xml-decode', 1, 'enable', 1, '不安全的XML Decode', '当用户输入以不安全的方式插入到服务器端XML文档或SOAP消息中时，就会XML外部实体注入漏洞。恶意用户可构造XML元自付破坏XML原本结构，从而查看应用服务器本地文件或对应用同一网络环境下的应用进行间接攻击。', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'sql-injection', 1, 'enable', 1, 'SQL注入', '软件使用来自上游组件的外部影响的输入来构造全部或部分SQL命令，但不会中和或不正确地中和了特殊元素，这些特殊元素在将其发送到下游组件时可能会修改预期的SQL命令。', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'ldap-injection', 1, 'enable', 1, 'LDAP注入', 'LDAP注入是指客户端发送查询请求时，输入的字符串中含有一些特殊字符，导致修改了LDAP本来的查询结构，从而使得可以访问更多的未授权数据的一种攻击方式。', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'xpath-injection', 1, 'enable', 1, 'XPATH注入', 'XPath注入攻击，是指利用XPath 解析器的松散输入和容错特性，能够在 URL、表单或其它信息上附带恶意的XPath 查询代码，以获得权限信息的访问权并更改这些信息。XPath注入攻击是针对Web服务应用新的攻击方法，它允许攻击者在事先不知道XPath查询相关知 识的情况下，通过XPath查询得到一个XML文档的完整内容。Xpath注入攻击本质上和SQL注入攻击是类似的，都是输入一些恶意的查询等代码字符串，从而对网站进行攻击。', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'path-traversal', 1, 'enable', 1, '路径穿越', 'CWE-23，该软件使用外部输入来构建路径名，该路径名应位于受限目录内，但不能正确中和诸如“ ..”之类的序列，这些序列可以解析到该目录之外的位置。', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'crypto-weak-randomness', 3, 'enable', 1, '弱随机数算法', '随机数在计算机应用中使用的比较广泛，最为熟知的便是在密码学中的应用。随机数分为真随机数和伪随机数，我们程序使用的基本都是伪随机数。伪随机又分为强伪随机数和弱伪随机数。伪随机数，通过一定算法和种子得出。软件实现的是伪随机数。强伪随机数，难以预测的随机数。弱伪随机数，易于预测的随机数。\nJava程序中，使用java.util.Random获得随机数，这种随机数源于伪随机数生成器，产生的随机数容易被预测，对于安全性要求较高的环境中，使用这种随机数可能会降低系统安全性，使攻击者有机可乘。', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'crypto-bad-mac', 3, 'enable', 1, '弱哈希算法', '哈希算法是使用哈希函数将任意长度的消息映射成为一个长度较短且长度固定的值，这个经过映射的值为哈希值。它是一种单向加密体制，即一个从明文到密文的不可逆映射，只有加密过程，没有解密过程。而不安全的哈希算法则可以逆向推出明文。在密码学中，哈希算法主要用于消息摘要和签名来对整个消息的完整性进行校验，所以需要哈希算法无法推导输入的原始值，这是哈希算法安全性的基础。目前常用的哈希算法包括MD4、MD5、SHA等。本篇文章以JAVA语言源代码为例，分析不安全的哈希算法缺陷产生的原因以及修复方法。详细请参见：CWE ID 327: Use of a Broken or Risky Cryptographic Algorithm (http://cwe.mitre.org/data/definitions/327.html)。', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'crypto-bad-cipher', 3, 'enable', 1, '弱加密算法', '数据通过弱加密算法MessageDigest函数进行加密', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'cookie-flags-missing', 3, 'enable', 1, 'Cookie未设置secure', '没有设置HTTPS会话中敏感cookie的安全属性，这可能导致用户代理通过HTTP会话以明文发送这些cookie。', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'trust-boundary-violation', 3, 'enable', 1, '信任边界', 'CWE-501，信任边界可以认为是通过程序绘制的线。 在生产线的一侧，数据不受信任。 在该行的另一端，假定数据是可信的。 验证逻辑的目的是允许数据安全地越过信任边界-从不受信任变为受信任。 当程序模糊了可信和不可信之间的界限时，就会发生信任边界冲突。 通过在同一数据结构中组合可信数据和不可信数据，程序员可以更容易地错误地信任未验证的数据。', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'reflected-xss', 2, 'enable', 1, '反射型xss', '跨站脚本攻击漏洞简称XSS漏洞,主要是由于应用后端未对用户输入进行安全校验或校验不严格导致恶意用户可自定义控制页面输出内容，从而产生跨站脚本攻击漏洞。通常来说恶意用户通过构造闭合标签方式在HTML页面中插入Javascript代码，在正常用户浏览此页面时对正常用户进行攻击，常见的攻击方式有获取用户的身份凭据、对用户内网进行探测扫描、执行钓鱼欺骗攻击等', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'header-injection', 3, 'enable', 1, 'Header头注入', 'HTTP响应拆分漏洞，也叫CRLF注入攻击。CR、LF分别对应回车、换行字符。攻击者可能注入自定义HTTP头。例如，攻击者可以注入会话cookie或HTML代码。这可能会进行类似的XSS（跨站点脚本）或会话固定漏洞。', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'hql-injection', 1, 'enable', 1, 'HQL注入', 'CWE-564，使用Hibernate执行使用用户控制的输入构建的动态SQL语句，可使攻击者修改该语句的含义或执行任意SQL命令。', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'unsafe-readline', 3, 'enable', 1, '不安全的readline', '使用不安全的方法进行行数据读取', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'expression-language-injection', 1, 'enable', 1, '表达式注入', 'CWE-917，该软件使用来自上游组件的外部影响的输入来构造Java Server Page（JSP）中的全部或部分表达语言（EL）语句，但不会中和或错误地中和了可以修改预期的EL语句的特殊元素。它被执行。', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'redos', 3, 'enable', 1, '正则DOS', 'CWE-185，使用的正则表达式会导致数据不正确的匹配或比较，造成程序响应速度变慢', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'reflection-injection', 1, 'enable', 1, '反射注入', '使用反射方式动态加载用户输入的类名，如果未做过滤，可加载恶意类产生命令执行等风险。', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'nosql-injection', 1, 'enable', 1, 'NoSql注入', 'NoSQL(泛指非关系型的数据库)注入是指服务端充分信任用户输入导致输入带入查询操作，导致用户可控制数据库查询语句；但由于nosql数据库不同于传统数据库的语法，由于各个数据库之间使用语法、API一般不同，NoSQL注入攻击可能在应用程序的不同区域执行，具体取决于使用的NoSQL API和数据模型；NoSQL注入按照攻击途径又分五类：重言式/永真式、联合查询、JavaScript注入、背负式查询、跨域违规；', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'unvalidated-redirect', 3, 'enable', 1, '不安全的重定向', 'CWE-601，Web应用程序接受用户控制的输入，该输入指定到外部站点的链接，并在重定向中使用该链接，简化了网络钓鱼攻击。', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'unvalidated-forward', 3, 'enable', 1, '不安全的转发', '验证服务端是否使用不受信任的数据链接进行重定向。', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'crypto-bad-ciphers', 3, 'enable', 1, '弱加密算法', '数据通过弱加密算法MessageDigest函数进行加密', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'dynamic-library-load', 1, 'enable', 1, 'JNI注入', 'JNI注入是指由于WEB应用程序对用户提交的JNI包过滤不严格，导致攻击者可以通过构造恶意JNI包并动态加载至WEB应用中', '这里是修复建议');
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'xxe', 2, 'enable', 1, 'XXE', 'XML 指可扩展标记语言（eXtensible Markup Language），是一种用于标记电子文件使其具有结构性的标记语言，被设计用来传输和存储数据。XML文档结构包括XML声明、DTD文档类型定义（可选）、文档元素。目前，XML文件作为配置文件（Spring、Struts2等）、文档结构说明文件（PDF、RSS等）、图片格式文件（SVG header）应用比较广泛。 XML 的语法规范由 DTD （Document Type Definition）来进行控制。\n\nXML外部实体注入（XML External Entity Injection）漏洞是指当恶意用户在提交一个精心构造的包含外部实体引用的XML文档给未正确配置的XML解析器处理时，该攻击就会发生。', NULL);
INSERT INTO `iast_strategy`(`user_id`, `vul_type`, `level_id`, `state`, `dt`, `vul_name`, `vul_desc`, `vul_fix`) VALUES (1, 'unsafe-json-deserialize', 1, 'enable', 1, '不安全的JSON反序列化', '不安全的JSON反序列化是指WEB应用程序对用户提交的反序列化数据未进行有效过滤，导致反序列化过程中产生命令执行、文件读取等漏洞', NULL);

INSERT INTO `iast_vul_level`(`name`, `name_value`, `name_type`) VALUES ('high', '高危', '高危漏洞');
INSERT INTO `iast_vul_level`(`name`, `name_value`, `name_type`) VALUES ('medium', '中危', '中危漏洞');
INSERT INTO `iast_vul_level`(`name`, `name_value`, `name_type`) VALUES ('low', '低危', '低危漏洞');
INSERT INTO `iast_vul_level`(`name`, `name_value`, `name_type`) VALUES ('info', '提示', '提示信息');

-- 创建默认用户
INSERT INTO `auth_user`(`password`, `last_login`, `is_superuser`, `username`, `first_name`, `last_name`, `email`, `is_staff`, `is_active`, `date_joined`, `phone`) VALUES ('pbkdf2_sha256$180000$tpUFyXYrIGXh$PIqkgklZerTwKsDe5s9P+6USI/Z2Yq+5J6oXx4kbiKI=', '2021-03-23 18:32:44.117558', 2, 'admin', 'admin', 'admin', 'admin@huoxian.cn', 1, 1, '2020-01-01 00:00:00.000000', 1);

-- 创建租户
INSERT INTO `auth_talent`(`talent_name`, `create_time`, `update_time`, `created_by`, `is_active`) VALUES ('默认租户', 1610532209, 1611031026, 1, 1);

-- 创建部门
INSERT INTO `auth_department`(`name`, `create_time`, `update_time`, `created_by`, `parent_id`) VALUES ('默认部门', 1611031807, 1611045352, 1, -1);

-- 创建组
INSERT INTO `auth_group`(`name`) VALUES ('system_admin');
INSERT INTO `auth_group`(`name`) VALUES ('talent_admin');
INSERT INTO `auth_group`(`name`) VALUES ('user');

-- 创建关联关系
INSERT INTO `auth_department_talent`(`department_id`, `talent_id`) VALUES (1, 1);
INSERT INTO `auth_user_department`(`user_id`, `department_id`) VALUES (1, 1);
INSERT INTO `auth_user_groups`(`user_id`, `group_id`) VALUES (1, 2);

SET FOREIGN_KEY_CHECKS = 1;